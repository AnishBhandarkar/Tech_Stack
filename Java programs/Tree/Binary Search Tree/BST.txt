package com.practice;

/* OPERATION ON BST
 * Insertion
 * Deletion
 * Search
 * Traversal
 * Min/Max node
 * Number of leaf/non-leaf/total nodes
 * Delete tree
 */

class BST{
	Node root;
	Node temp;
	private class Node{
		private int data;
		private Node left;
		private Node right;
		
		Node(int data){
			this.data = data;
		}
	}
	
	public void print2D(Node root, int space) {
		if(root==null) {
			return;
		}
		space+=10;
		print2D(root.right, space);
		System.out.println();
		for(int i=10;i<space;i++) {
			System.out.print(" ");
		}
		System.out.println(root.data);
		print2D(root.left, space);
	}
	
	//BST Search Recursive
	public void searchRecursive(Node root, int data) {
		if(root==null) {
			System.out.println("Not found");
			return;
		}
		if(data == root.data) {
			System.out.println("Found");
			return;
		}
		else if(data < root.data) {
			searchRecursive(root.left, data);
		}
		else {
			searchRecursive(root.right, data);
		}
	}
	
	//BST Search Iterative
	public void searchIterative(int data) {
		Node temp = root;
		while(temp != null) {
			if(data == temp.data) {
				System.out.println("Found");
				return;
			}
			else if(data < temp.data) {
				temp = temp.left;
			}
			else {
				temp = temp.right;
			}
		}
		if(root==null || temp == null) {
			System.out.println("Not found");
			return;
		}
	}
	
	public void inOrder(Node root) {
		if(root==null) {
			return;
		}
		inOrder(root.left);
		System.out.print(root.data+" ");
		inOrder(root.right);
	}
	
	public void preOrder(Node root) {
		if(root==null) {
			return;
		}
		System.out.print(root.data+ " ");
		preOrder(root.left);
		preOrder(root.right);
	}
	
	public void postOrder(Node root) {
		if(root==null) {
			return;
		}
		postOrder(root.left);
		postOrder(root.right);
		System.out.print(root.data+" ");
	}
	
	public Node insertRecursive(Node root, int data) {
		if(root == null) {
			root = new Node(data);
		}
		else if(data < root.data) {
			root.left = insertRecursive(root.left, data);
		}
		else {
			root.right = insertRecursive(root.right, data);
		}
		return root;
	}
	
	public Node insert(Node root, int data) {
		Node node = new Node(data);
		if(root==null) {
			root = node;
			return root;
		}
		Node prev, cur;
		prev = null;
		cur = root;
		while(cur != null) {
			prev = cur;
			if(data > cur.data) {
				cur = cur.right;
			}
			else {
				cur = cur.left;
			}
		}
		if(data < prev.data) {
			prev.left = node;
		}
		else {
			prev.right = node;
		}
		return root;
		
	}

	
	public Node inorderPredecessor(Node root) {
		root = root.left;
		if(root == null) {
			return null;
		}
		while(root.right != null) {
			root = root.right;
		}
		return root;
	}
	
	public Node inorderSucecessor(Node root) {
		root = root.right;
		if(root == null) {
			return null;
		}
		while(root.left != null) {
			root = root.left;
		}
		return root;
	}

	
	public Node delete(Node root, int data) {
		if(root==null) {
			return null;
		}
		if(root.left ==null && root.right==null) {
			root = null;
			return null;
		}
		if(data < root.data) {
			root.left = delete(root.left, data);
		}
		else if(data > root.data) {
			root.right = delete(root.right, data);
		}
		else {
			Node inPre = inorderPredecessor(root);
			if(inPre == null) {
				Node inSuc = inorderSucecessor(root);
				root.data = inSuc.data;
				root.right = delete(root.right, inSuc.data);
				return root;
			}
			root.data = inPre.data;
			root.left = delete(root.left, inPre.data);
		}
		return root;
	}

	/*Height of a node : maximum number of nodes on the longest path from that node to a leaf node(Inclusive)
	 *Height of tree == Height of root node  */
	public int height(Node root) {
		if(root == null) {
			return 0;
		}
		int left = height(root.left);
		int right = height(root.right);
		return Math.max(left, right)+1;
	}
	
	public int countNodes(Node root) {
		if(root == null) {
			return 0;
		}
		return countNodes(root.left)+countNodes(root.right)+1;
	}
	
	public int countInternalNodes(Node root) {
		if(root == null) {
			return 0;
		}
		if(root.left == null && root.right == null) {
			return 0;
		}
		return countInternalNodes(root.left)+countInternalNodes(root.right)+1;
	}
	
	public int countLeafNodes(Node root) {
		if(root == null) {
			return 0;
		}
		if(root.left == null && root.right == null) {
			return 1;
		}
		else {
			return countLeafNodes(root.left)+countLeafNodes(root.right);	
		}
	}
	
	public int minData(Node root) {
		if(root == null) {
			return -1;
		}
		if(root.left == null) {
			return root.data;
		}
		return minData(root.left);
	}
	
	public int maxData(Node root) {
		if(root == null) {
			return -1;
		}
		if(root.right == null) {
			return root.data;
		}
		return maxData(root.right);
	}
	
	//Deletes entire tree
	public void deleteTree() {
		root = null;	
	}
	
}

public class Practice1 {
	
	public static void main(String[] args) {
		BST b = new BST();
		System.out.println(b.maxData(b.root));
		b.root = b.insert(b.root, 45);
		b.root = b.insert(b.root, 39);
		b.root = b.insert(b.root, 56);
		b.root = b.insert(b.root, 12);
		b.root = b.insert(b.root, 78);
		b.print2D(b.root, 5);
		b.inOrder(b.root);
		System.out.println();
		System.out.println(b.countLeafNodes(b.root));
		

		
	}
}


/*

Notes:
-----

public Node insertRecursive(Node root, int data) {
		//1.Node node = new Node(data);
		if(root == null) {
			root = new Node(data);
		}
		else if(data < root.data) {
			root.left = insertRecursive(root.left, data);
		}
		else {
			root.right = insertRecursive(root.right, data);
		}
		return root;
}

Line 1 is avoided because in each recursive call, it will create a new node.
so we put them within if statement.







*/