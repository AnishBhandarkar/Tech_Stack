package com.practice;


class CircularQueue{
	private int[] que;
	private int size;
	private int front=-1;
	private int rear=-1;
	
	CircularQueue(int size){
		this.size=size;
		que = new int[size];
	}
	
	public boolean isEmpty() {
		return (front==-1 && rear==-1)?true:false;
	}
	
	public boolean isFull() {
		return ((rear+1)%size == front)?true:false;
	}
	
	public void enqueue(int data) {
		if(isFull()) {
			System.out.println("Queue Overflow");
			return;
		}
		if(isEmpty()) {
			front = 0;
			rear = 0;
		}
		else {
			rear = (rear+1)%size;
		}
		que[rear] = data;
	}
	
	public int dequeue() {
		if(isEmpty()) {
			System.out.println("Queue Underflow");
			return -1;
		}
		int data = que[front];
		if(front==rear) {
			front=rear=-1;
		}
		else {
			front = (front+1)%size;
		}
		return data;
	}
	
	public int getFront() {
		return isEmpty()? -1 : que[front];
	}
	
	public int getRear() {
		return isEmpty()? -1 : que[rear];
	}
	
	public void display() {
		if(isEmpty()) {
			System.out.println("Queue Underflow");
			return;
		}
		int length = (rear + size -front)%size +1;
		for(int i=0;i<length;i++) {
			System.out.print(que[(front+i)%size] + " ");
		}
		System.out.println();
	}
}


public class Practice1{
	public static void main(String[] args) {
		CircularQueue q = new CircularQueue(10);
		q.display();
		q.enqueue(10);
		q.enqueue(20);
		q.enqueue(30);
		q.enqueue(40);
		q.enqueue(50);
		q.display();
		System.out.println(q.dequeue());
		q.display();
		System.out.println(q.isEmpty());
		System.out.println(q.getFront());
		System.out.println(q.getRear());
	}
}





